(function(e){function n(n){for(var r,o,s=n[0],l=n[1],c=n[2],v=0,m=[];v<s.length;v++)o=s[v],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&m.push(i[o][0]),i[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(e[r]=l[r]);u&&u(n);while(m.length)m.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var e,n=0;n<a.length;n++){for(var t=a[n],r=!0,s=1;s<t.length;s++){var l=t[s];0!==i[l]&&(r=!1)}r&&(a.splice(n--,1),e=o(o.s=t[0]))}return e}var r={},i={app:0},a=[];function o(n){if(r[n])return r[n].exports;var t=r[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.m=e,o.c=r,o.d=function(e,n,t){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,n){if(1&n&&(e=o(e)),8&n)return e;if(4&n&&"object"===typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)o.d(t,r,function(n){return e[n]}.bind(null,r));return t},o.n=function(e){var n=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="/webgl/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],l=s.push.bind(s);s.push=n,s=s.slice();for(var c=0;c<s.length;c++)n(s[c]);var u=l;a.push([0,"chunk-vendors"]),t()})({0:function(e,n,t){e.exports=t("56d7")},"21c7":function(e,n,t){"use strict";t("f941")},"56d7":function(e,n,t){"use strict";t.r(n);t("e260"),t("e6cf"),t("cca6"),t("a79d");var r=t("7a23");function i(e,n){var t=Object(r["t"])("router-view");return Object(r["n"])(),Object(r["c"])(t)}t("21c7");var a=t("6b0d"),o=t.n(a);const s={},l=o()(s,[["render",i]]);var c=l,u=(t("ac1f"),t("466d"),t("6c02")),v={class:"home"};function m(e,n,t,i,a,o){return Object(r["n"])(),Object(r["d"])("div",v," pc ")}var h={name:"Home",components:{},mounted:function(){}};const d=o()(h,[["render",m]]);var p=d,f=function(e){return Object(r["q"])("data-v-020dc968"),e=e(),Object(r["o"])(),e},g={class:"about"},w={class:"mbHead"},x=f((function(){return Object(r["e"])("div",{class:"bigTitle"},null,-1)})),y={class:"mbBody",ref:"mbBody"},b={class:"menu"},j={class:"col_"},P=f((function(){return Object(r["e"])("br",null,null,-1)})),C={class:"col_"},D=f((function(){return Object(r["e"])("br",null,null,-1)})),M={class:"mbContents"},z={key:0},S=f((function(){return Object(r["e"])("br",null,null,-1)})),_=f((function(){return Object(r["e"])("h2",null,"点击下方文字浏览",-1)})),T=f((function(){return Object(r["e"])("br",null,null,-1)})),F=f((function(){return Object(r["e"])("br",null,null,-1)})),k=f((function(){return Object(r["e"])("br",null,null,-1)})),O=f((function(){return Object(r["e"])("br",null,null,-1)})),U=f((function(){return Object(r["e"])("br",null,null,-1)})),L=f((function(){return Object(r["e"])("br",null,null,-1)})),I=f((function(){return Object(r["e"])("br",null,null,-1)})),V=f((function(){return Object(r["e"])("br",null,null,-1)})),W=f((function(){return Object(r["e"])("br",null,null,-1)})),N=f((function(){return Object(r["e"])("br",null,null,-1)})),R=f((function(){return Object(r["e"])("br",null,null,-1)})),B=f((function(){return Object(r["e"])("br",null,null,-1)})),G=f((function(){return Object(r["e"])("br",null,null,-1)})),A=f((function(){return Object(r["e"])("br",null,null,-1)})),E={key:1};function Z(e,n,t,i,a,o){return Object(r["n"])(),Object(r["d"])("div",g,[Object(r["e"])("div",w,[x,Object(r["z"])(Object(r["e"])("div",{class:"menuBtn",onClick:n[0]||(n[0]=function(){return o.openMenu&&o.openMenu.apply(o,arguments)})},null,512),[[r["x"],a.showMenu]]),Object(r["z"])(Object(r["e"])("div",{class:"menuBtnClose",onClick:n[1]||(n[1]=function(){return o.openMenu&&o.openMenu.apply(o,arguments)})},null,512),[[r["x"],!a.showMenu]])]),Object(r["e"])("div",y,[Object(r["z"])(Object(r["e"])("div",b,[Object(r["e"])("div",j,[Object(r["e"])("span",{onClick:n[2]||(n[2]=function(e){return o.jump(0,"首页")})},"首页"),P,Object(r["e"])("span",{onClick:n[3]||(n[3]=function(e){return o.jump(1,"技能经验")})},"技能经验")]),Object(r["e"])("div",C,[Object(r["e"])("span",{onClick:n[4]||(n[4]=function(e){return o.jump(2,"作品")})},"作品"),D,Object(r["e"])("span",{onClick:n[5]||(n[5]=function(e){return o.jump(3,"寻找我")})},"寻找我")])],512),[[r["x"],a.showMenu]])],512),Object(r["e"])("div",M,[2==a.curPg?(Object(r["n"])(),Object(r["d"])("div",z,[S,_,T,F,Object(r["e"])("span",{onClick:n[6]||(n[6]=function(e){return o.changeWoker("heat")})},"热力图 : 用于显示某地区的某种数据密度。"),k,O,Object(r["e"])("span",{onClick:n[7]||(n[7]=function(e){return o.changeWoker("vid")})},"视频融合 : 将监控探头拍摄的街景直接映射到地图上，用于动态观察街道情况。"),U,L,Object(r["e"])("span",{onClick:n[8]||(n[8]=function(e){return o.changeWoker("water")})},"水体模拟 ：Cesium功能强大，但在视觉体验上并没有过多优化。比如海水仅仅用贴图来模拟。我写了个ScreenSpaceReflection着色器实现了有倒影的水面特效。"),I,V,Object(r["e"])("span",{onClick:n[9]||(n[9]=function(e){return o.changeWoker("viewShed")})},"视域透视 ：用来分析视角范围和死角，看不见的地方用红色标记，绿色则为可视区域，利用了ShadowMap的原理进行实现。"),W,N,Object(r["e"])("span",{onClick:n[10]||(n[10]=function(e){return o.changeWoker("phy")})},"布料模拟 ：利用Ammo.js物理引擎实现的柔体和刚体的碰撞模拟。"),R,B,Object(r["e"])("span",{onClick:n[11]||(n[11]=function(e){return o.changeWoker("CO2")})},"水晶 ：利用法线扭曲光线方向进行取样。"),G,A])):(Object(r["n"])(),Object(r["d"])("div",E,Object(r["v"])(a.contentText),1))])])}t("38cf");var Q,J=t("5a89"),X=t("d4ec"),H=t("bee2"),Y=function(){function e(n){Object(X["a"])(this,e),this.camera=n.camera,this.light=n.lightCamera,this.noiseTexture=n.noiseTexture,this.targetFrontSide=this.setupRenderTarget(),this.composer=n.composer,this.scene3=n.scene3,this.mainSceneTarget=n.target}return Object(H["a"])(e,[{key:"setupRenderTarget",value:function(){var e=new J["Db"](window.width,window.height);return e.texture.minFilter=J["U"],e.texture.magFilter=J["U"],e.stencilBuffer=J["m"]===J["n"],e.texture.type=J["t"],e.texture.format=J["ib"],e}},{key:"resize",value:function(){this.targetFrontSide.setSize(window.width,window.height),this.cloud&&(this.cloud.material.uniforms.w.value=window.width,this.cloud.material.uniforms.h.value=window.height)}},{key:"createCloud",value:function(){var e=new J["l"](1e4,1e4,400,32),n=new J["lb"]({uniforms:{},glslVersion:J["v"],side:J["u"],vertexShader:"\n                varying vec3 v_wPos;\n                void main(){\n                    vec4 wPos = modelMatrix * vec4( position, 1.0 );\n                    v_wPos = wPos.xyz;\n                    gl_Position = projectionMatrix * viewMatrix * wPos;\n                }\n            ",fragmentShader:"\n                #include <packing>\n                varying vec3 v_wPos;\n                layout(location = 0) out vec4 gColor;\n                void main(){\n                    gColor = vec4(v_wPos,1.); //v_wPos,\n                }\n            "}),t=new J["P"](e,n);t.position.y=1e3,this.scene3.add(t),this.geometry=new J["l"](1e4,1e4,400,32),this.material=new J["lb"]({glslVersion:J["v"],transparent:!0,side:J["c"],uniforms:{cameraPos:{value:this.camera.position},projectionMatrixInverse:{value:this.camera.projectionMatrixInverse},cameraProjectionMatrix:{value:this.camera.projectionMatrix},cameraWorldMatrix:{value:this.camera.matrixWorld},matrixWorld:{value:this.camera.matrixWorld},perlinTexture:{value:this.noiseTexture},time:{value:0},centerHeight:{value:90},lightPos:{value:this.light.position},lightDirLength:{value:50},lightPow:{value:.3},posTexture:{value:null},w:{value:window.width},h:{value:window.height},cameraNear:{value:this.camera.near},cameraFar:{value:this.camera.far}},vertexShader:"\n            varying vec4 v_position;\n            varying vec4 v_eyePosition;\n            varying vec3 v_pToCamera;\n            varying vec4 v_pjPosition;\n            varying mat4 projection;\n            varying mat4 view;\n            uniform vec3 cameraPos;\n                void main(){\n                    v_position = modelMatrix * vec4( position, 1.0 );\n                    v_pToCamera = v_position.xyz-cameraPos;\n                    v_eyePosition = modelViewMatrix * vec4( position, 1.0 );\n                    v_pjPosition = projectionMatrix * v_eyePosition;\n                    projection = projectionMatrix;\n                    view = viewMatrix;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }\n            ",fragmentShader:"\n            #include <packing>\n            precision highp sampler3D;\n            float bottom = 800.0;   // 云层底部\n            float top = 1200.0;      // 云层顶部\n            float width = 1000.0;    // 云层 xz 坐标范围 [-width, width]\n            layout(location = 0) out vec4 gColor;\n            varying vec4 v_position;\n            varying vec4 v_eyePosition;\n            varying vec4 v_pjPosition;\n            uniform vec3 cameraPos;\n\n            uniform mat4 projectionMatrixInverse;\n            uniform mat4 cameraProjectionMatrix;\n            uniform mat4 matrixWorld;\n            uniform sampler2D perlinTexture;\n\n            varying mat4 projection;\n            varying mat4 view;\n            varying vec3 v_pToCamera;\n\n            #define baseBright  vec3(0.55,0.55,0.6)    // 基础颜色 -- 亮部\n            #define baseDark    vec3(0.21,0.21,0.21)    // 基础颜色 -- 暗部\n            #define lightBright vec3(1.0, 0.9, 0.9)  // 光照颜色 -- 亮部 1.29, 1.17, 1.05\n            #define lightDark   vec3(0.45,0.50,0.54)      // 光照颜色 -- 暗部 0.7,0.75,0.8\n\n            // uniform sampler2D depthMain;\n            uniform float time;\n            uniform vec3 lightPos;\n            uniform float lightDirLength;\n            uniform float lightPow; //灯光亮度\n\n            uniform sampler2D posTexture;\n            uniform float w;\n            uniform float h;\n            uniform float cameraNear;\n            uniform float cameraFar;\n            uniform mat4 cameraWorldMatrix;\n            // uniform sampler2D mainSceneDepth;\n            //3D噪声\n            float noise(vec3 x)\n            {\n                vec3 p = floor(x);\n                vec3 f = fract(x);\n                f = smoothstep(0.0, 1.0, f);\n                \n                vec2 uv = (p.xy+vec2(37.0, 17.0)*p.z) + f.xy;\n                float v1 = texture2D( perlinTexture, (uv)/256.0, -100.0 ).x;\n                float v2 = texture2D( perlinTexture, (uv + vec2(37.0, 17.0))/256.0, -100.0 ).x;\n                return mix(v1, v2, f.z);\n            }\n            float getCloudNoise(vec3 worldPos) {\n                vec3 coord = worldPos;\n                coord.x += time*0.005;//移动\n                coord.z += time*0.005;\n                coord.y -= time*0.025 ;\n                coord *= 0.008;\n                float n = noise(coord) * 0.5;   coord *= 3.0;\n                    n += noise(coord) * 0.25;  coord *= 3.01;\n                    n += noise(coord) * 0.125; coord *= 3.02;\n                    n += noise(coord) * 0.0625; \n                return max(n - 0.5, 0.0) * (1.0 / (1.0 - 0.5));\n            }\n\n\n            float getDensity(vec3 pos) {\n                vec3 p = pos;\n                p.z *= 0.5; //防止纹理变形，调整为正方形\n                float noise = getCloudNoise(p);\n                return noise*3.;\n            }\n            float random (vec2 st) {\n                return fract(sin(dot(st.xy,\n                                    vec2(12.9898,78.233)))*\n                    43758.5453123);\n            }\n            float linearizeDepth(float depth) {\n                return (2.0 * cameraNear) / (cameraFar + cameraNear - depth * (cameraFar - cameraNear));\n            }\n            vec4 getCloud(){\n                vec3 fragToCam= v_pToCamera;\n                vec3 direction = normalize(fragToCam);\n                vec3 step = direction * 12.5 + random(direction.xz)*0.1  ;\n                vec4 colorSum = vec4(0);        // 积累的颜色\n\n                vec2 screen = gl_FragCoord.xy/vec2(w,h);\n                vec4 poss = texture2D(posTexture,screen);\n                vec3 point = poss.xyz;         // 从相机出发开始测试\n                //优化，把起点移动到当前片元云的坐标 gl_FragCoord.z深度求出eye坐标再转为世界坐标\n                float loopUpper = 100.;//上限\n                if(cameraPos.y>bottom && cameraPos.y<top){\n                    point = cameraPos;//\n                }\n                \n                float x_ = length(v_eyePosition);\n                int loop = int((  0.00125* (x_)  * exp(1.- 0.00125*(x_))  )*loopUpper); //400次循环\n                for(int i=0; i< loop; i++) {\n                    point += step;\n                    if(point.y>top || point.y<bottom){\n                        break;\n                    }\n                    //判断有没有与主场景物体香蕉，有则跳出\n                    // vec4 screenPos = projection * view * vec4(point, 1.0);\n                    // screenPos /= screenPos.w;\n                    // screenPos.xyz = screenPos.xyz * 0.5 + 0.5;\n                    // 深度采样\n                    // float sampleDepth = texture2D(mainSceneDepth, screenPos.xy).r;    // 采样深度\n                    // float testDepth = screenPos.z;  // 测试深度\n                    \n                    // 深度线性化\n                    // sampleDepth = linearizeDepth(sampleDepth);\n                    // testDepth = linearizeDepth(testDepth);\n                    // if(sampleDepth<testDepth) {\n                    //     break;\n                    // }\n\n                    float density = getDensity(point) ;\n                    \n                    vec3 L;\n                    float lightDensity;\n                    for(int j=0;j<2;j++){\n                        L += normalize(lightPos - point)*lightDirLength; // 光源方向  迭代次数越多，越精准\n                        lightDensity += getDensity(point + L);\n                    }\n                    \n                   \n                    float delta = clamp(density - lightDensity,0.0, 1.0);      // 两次采样密度差\n\n                    vec3 base = baseBright* density; \n\n                    \n                    vec3 light = mix(lightDark, lightBright, delta) * lightPow;            // 光照对颜色影响\n                    float border = 0.04; //黑边，\n                    vec4 color = vec4(base *light \n                                        ,density-border);                           // 当前点的最终颜色\n                    colorSum = color * (1.0 - colorSum.a) + colorSum;           // 与累积的颜色混合\n\n                }\n                \n                return colorSum;\n            }\n            \n            void main(){\n                \n                vec4 cloud = getCloud(); // 云颜色\n                vec4 fColor;\n                fColor.rgb = cloud.rgb;    // 混色\n                fColor.a = cloud.a;\n\n                \n                // vec2 screen = gl_FragCoord.xy/vec2(w,h);\n                // float d = texture2D(mainSceneDepth,screen).r;\n                // d = perspectiveDepthToViewZ( d, cameraNear, cameraFar );\n                // fColor.r = -d;\n                gColor = fColor;\n            }\n            "});var r=new J["P"](this.geometry,this.material),i=1e3;return r.position.y=i,this.cloud=r,r}},{key:"loop",value:function(e){this.cloud&&(this.cloud.material.uniforms.time.value=e,this.material&&(this.material.uniforms.projectionMatrixInverse.value=this.camera.projectionMatrixInverse,this.material.uniforms.cameraProjectionMatrix.value=this.camera.projectionMatrix,this.material.uniforms.cameraWorldMatrix.value=this.camera.matrixWorld,this.composer.renderer.setRenderTarget(this.targetFrontSide),this.composer.renderer.render(this.scene3,this.camera),this.cloud.material.uniforms.posTexture.value=this.targetFrontSide.texture,this.composer.renderer.setRenderTarget(null)))}}]),e}(),q=t("32d9"),K=t("93e9"),$=t("9ab2"),ee=t("360d"),ne=function(){function e(n){Object(X["a"])(this,e),this.lightCamera=n.lightCamera,this.target=n.target,this.targetN=this.setupRenderTargetNormal(),this.targetLightCamera=this.setupRenderTargetLightCamera(),this.scene2=n.scene2,this.scene=n.scene,this.lightCamera=n.lightCamera,this.camera=n.camera,this.material=null,this.composer=n.composer,this.shaderPass=new ee["a"]({glslVersion:J["v"],uniforms:{tDiffuse:{value:null},tDepth:{value:null},cameraNear:{value:n.camera.near},cameraFar:{value:n.camera.far},tNormal:{value:null},groundDepth:{value:null},projectionMatrixInverse:{value:n.camera.projectionMatrixInverse},cameraProjectionMatrix:{value:n.camera.projectionMatrix},cameraViewMatrix:{value:n.camera.matrixWorldInverse},u_worldMatrix:{value:n.camera.matrixWorld},u_resolution:{value:new J["zb"](window.width,window.height)},groundTexture:{value:null},lightPos:{value:this.lightCamera.position},eyePositionTexture:{value:null}},vertexShader:"\n            varying vec2 vUv;\n            varying vec3 v_position;\n            varying mat4 v_mvMatrix;\n            uniform vec3 lightPos;\n            varying vec4 lightEyePos;\n            uniform mat4 cameraViewMatrix;\n            void main() {\n                vUv = uv;\n                v_mvMatrix = modelViewMatrix;\n                lightEyePos =  cameraViewMatrix *vec4(lightPos,1.); //\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n            }",fragmentShader:"\n            #include <packing>\n            varying vec2 vUv;\n            uniform float cameraNear;\n            uniform float cameraFar;\n            uniform sampler2D tDiffuse;\n            uniform sampler2D tDepth;\n            uniform sampler2D tNormal;\n            uniform sampler2D groundDepth;\n            uniform mat4 projectionMatrixInverse;\n            uniform mat4 cameraProjectionMatrix;\n            uniform mat4 u_worldMatrix;\n            uniform vec2 u_resolution;\n            uniform sampler2D groundTexture;\n            // uniform sampler2D onlyShadow;\n            uniform sampler2D eyePositionTexture;\n            varying vec4 lightEyePos;\n\n            struct hitSkyStruct{\n                vec2 uv;\n                float hitForSky;\n                vec4 reflectionColor;\n                vec4 positionFrom;\n                vec3 normal;\n            } hitSky;\n            \n            vec3 getViewNormal( const in vec2 uv ) {\n                return  unpackRGBToNormal(texture2D( tNormal, uv ).xyz);// unpackRGBToNormal();\n            }\n            float getViewZ( const in float depth ) {\n                return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n            }\n            float linearizeDepth(float depth) {\n                return (2.0 * cameraNear) / (cameraFar + cameraNear - depth * (cameraFar - cameraNear));\n            }\n            vec4 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n                vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n                clipPosition *= clipW; //clip\n                return ( projectionMatrixInverse * clipPosition );//view\n            }\n            \n            hitSkyStruct doFlactionForSky(float depthMain,float depthGround,float maxD,float res,float thickn,float cha,float skip){\n                float maxDistance = maxD;\n                float resolution  = res;\n                int   steps       = 4;\n                float thickness   = thickn;\n                vec2 texSize  = u_resolution;\n                vec2 texCoord = gl_FragCoord.xy / texSize;\n\n                vec4 uv = vec4(0.0);\n                float viewZ = depthGround;\n                float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];\n                vec4 positionFrom = getViewPosition(vUv, depthGround, clipW);\n\n                vec3 unitPositionFrom = normalize(positionFrom.xyz);\n                vec3 normal = normalize(getViewNormal(vUv));\n                vec3 pivot = normalize(reflect(unitPositionFrom, normal));\n\n                vec4 positionTo = positionFrom;\n\n                //vec4 startView = vec4(positionFrom.xyz + (pivot *         0.), 1.0);\n\n                vec4 startView = vec4(positionFrom.xyz + (pivot *  skip), 1.0);\n                vec4 endView   = vec4(positionFrom.xyz + (pivot * maxDistance), 1.0);\n\n                vec4 startFrag      = startView;\n                    startFrag      = cameraProjectionMatrix * startFrag;\n                    startFrag.xyz /= startFrag.w;\n                    startFrag.xy   = startFrag.xy * 0.5 + 0.5;\n                    startFrag.xy  *= texSize;\n\n                vec4 endFrag      = endView;\n                    endFrag      = cameraProjectionMatrix * endFrag;\n                    endFrag.xyz /= endFrag.w;\n                    endFrag.xy   = endFrag.xy * 0.5 + 0.5;\n                    endFrag.xy  *= texSize;\n\n                vec2 frag  = startFrag.xy;\n                uv.xy = frag / texSize;\n\n                float deltaX    = endFrag.x - startFrag.x;\n                float deltaY    = endFrag.y - startFrag.y;\n                float useX      = abs(deltaX) >= abs(deltaY) ? 1.0 : 0.0;\n                float delta     = mix(abs(deltaY), abs(deltaX), useX) * clamp(resolution, 0.0, 1.0);\n                vec2  increment = vec2(deltaX, deltaY) / max(delta, 0.001);\n\n                float search0 = 0.;\n                float search1 = 0.;\n\n                float hit0 = 0.;\n                float hit1 = 0.;\n\n                float viewDistance = startView.z;\n                float depth        = thickness;\n\n                int i = 0;\n                int len = int(delta);\n                \n                vec4 reflectionColor;\n                for (i = 0; i < len; ++i) {\n                    if(uv.x<0. || uv.y<0. || uv.x>1. ||uv.y>1.){\n                        hit0 = 0.;\n                        break;\n                    }\n                    frag      += increment;\n                    uv.xy      = frag / texSize;\n                    float dd = texture2D(tDepth,uv.xy).r;\n                    float viewZZ = getViewZ( dd );\n                    float clipWW = cameraProjectionMatrix[2][3] * viewZZ+cameraProjectionMatrix[3][3];\n                    positionTo = vec4( getViewPosition( uv.xy, dd, clipWW ).xyz,1.); \n                \n                    search1 =\n                    mix\n                        ( (frag.y - startFrag.y) / deltaY\n                        , (frag.x - startFrag.x) / deltaX\n                        , useX\n                        );\n                \n                    search1 = clamp(search1, 0.0, 1.0);\n                \n                    viewDistance = (startView.z * endView.z) / mix(endView.z, startView.z, search1);\n                    depth        = viewDistance - positionTo.z;\n                \n                    if (depth > cha && depth < thickness) {\n                        hit0 = 1.;\n                        reflectionColor = texture2D(tDiffuse,uv.xy);\n                        break;\n                    } else {\n                        search0 = search1;\n                    }\n                }\n                // return hit0;\n\n                hitSky = hitSkyStruct(\n                    uv.xy,\n                    hit0,\n                    reflectionColor,\n                    positionFrom,\n                    normal\n                    );\n                return hitSky;\n            }            \n            \n            void main() {\n                float maxDistance = 15.;\n                float resolution  = 0.5;\n                int   steps       = 4;\n                float thickness   = 0.5;\n                \n                \n                vec4 baseColor = texture2D(groundTexture,vUv);\n                // vec4 olShadow = blur(onlyShadow,vUv); //texture2D(onlyShadow,vUv);\n                // if(olShadow.a>0.2){\n                //     baseColor.rgb = baseColor.rgb-olShadow.r*0.3;\n                // }\n                vec4 color = texture2D(tDiffuse,vUv);\n                \n                float dg = texture2D(groundDepth,vUv).r;\n                float depthMain = getViewZ(texture2D(tDepth,vUv).r);\n                float depthGround = getViewZ(dg);\n                if(depthMain<depthGround){\n                    float hit0 = 0.;\n                    float cha0 = 10.;\n                    hitSkyStruct hitSt0 = doFlactionForSky(depthMain,depthGround,\n                        1000.\n                        ,0.5,25.0,cha0,0.);\n                    \n                    \n                    if(hitSt0.hitForSky==1.){\n                        gl_FragColor = mix(baseColor,hitSt0.reflectionColor,0.5);\n                    }else{\n                        float cha_ = 500.;\n\n                        hitSkyStruct hitSt = doFlactionForSky(depthMain,depthGround,10000.,0.5,2000.,cha_,500.);\n                        vec4 skyColor;\n                        if(hitSt.hitForSky==1.){\n                            skyColor = texture2D(tDiffuse,hitSt.uv)*4.;\n                            baseColor.rgb = mix(baseColor.rgb,skyColor.rgb,\n                                max(.5-distance(hitSt.uv,vec2(0.5,0.5)),0.)\n                                );\n                        }\n\n                        vec3 light   = normalize(lightEyePos.xyz - hitSt0.positionFrom.xyz);\n                        vec3 eye     = normalize(-hitSt0.positionFrom.xyz);\n                        vec3 halfway = normalize(light + eye);\n                        float specularIntensity = max(dot(hitSt0.normal.xyz, halfway),0.);\n                        specularIntensity = pow(specularIntensity,1600.)*5.;\n                        baseColor.r += specularIntensity;\n                        baseColor.g += specularIntensity;\n                        baseColor.b += specularIntensity;\n                        \n\n                        float alpha = 1.-length(hitSt0.positionFrom.xyz)/2500.;\n                        alpha = max(alpha,0.);\n                        baseColor.rgb = mix(color.rgb,baseColor.rgb,alpha);\n                        gl_FragColor = baseColor;\n                    }\n                }else{\n                    gl_FragColor = color;\n                }\n                \n\n            }"})}return Object(H["a"])(e,[{key:"setupRenderTargetNormal",value:function(){var e=new J["Cb"](window.width,window.height,2);return e.stencilBuffer=J["m"]===J["n"],e.depthTexture=new J["o"],e.depthTexture.format=J["m"],e.depthTexture.type=J["t"],e}},{key:"setupRenderTargetLightCamera",value:function(){var e=new J["Db"](2048,2048);return e.texture.minFilter=J["U"],e.texture.magFilter=J["U"],e.stencilBuffer=J["m"]===J["n"],e.depthTexture=new J["o"],e.depthTexture.format=J["m"],e.depthTexture.type=J["t"],e}},{key:"getShadowMaterial",value:function(e){var n=new J["lb"]({glslVersion:J["v"],uniforms:{nTexture:{value:e},u_vMatrixFromLight:{value:this.lightCamera.matrixWorldInverse},u_ProjectionMatrixFromLight:{value:this.lightCamera.projectionMatrix},depthTextureFromLightCamera:{value:null},time:{value:0},u_resolution:{value:new J["zb"](window.width,window.height)},lightPos:{value:this.lightCamera.position}},vertexShader:"\n            varying vec2 vUv;\n            varying vec2 vUv2;\n            varying vec3 v_normal;\n            varying vec4 result;\n            uniform mat4 u_vMatrixFromLight;\n            uniform mat4 u_ProjectionMatrixFromLight;\n            varying vec4 v_posFromLight;\n            uniform sampler2D nTexture;\n            uniform float time;\n            uniform vec3 lightPos;\n            void main() {\n                vUv = uv;\n                vUv *=4.;\n                vUv.y -= time*0.00003;\n\n                vUv2 = uv;\n                vUv2 *=4.;\n                vUv2.x -=time*0.00003;\n                \n                v_normal = normalMatrix * normalize(normal);\n                vec3 normal = texture2D(nTexture,vUv).xyz;\n                vec3 normal2 = texture2D(nTexture,vUv2).xyz;\n                vec3 p = position;\n                \n                p.z += normal.x*30.-normal2.x*30.;\n\n                v_posFromLight = u_ProjectionMatrixFromLight * u_vMatrixFromLight * modelMatrix * vec4( p, 1.0 );\n                vec4 wPos = modelMatrix*vec4( p, 1.0 );\n                vec4 eyePositionForTexture = viewMatrix * wPos;\n\n\n                gl_Position = projectionMatrix * eyePositionForTexture;\n\n            }",fragmentShader:"\n            #include <packing>\n            varying vec2 vUv;\n            varying vec2 vUv2;\n            varying vec3 v_normal;\n            uniform sampler2D nTexture;\n            layout(location = 0) out vec4 gColor;\n            layout(location = 1) out vec4 gNormal;\n            // layout(location = 2) out vec4 onlyShadow;\n            uniform float time;\n            varying vec4 v_posFromLight;\n            uniform sampler2D depthTextureFromLightCamera;\n            uniform vec2 u_resolution;\n            float blur(in sampler2D tx,in vec2 uv){\n                float Pi = 6.28318530718; // Pi*2\n                // GAUSSIAN BLUR SETTINGS {{{\n                float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n                float Quality = 3.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n                float Size = 4.0; // BLUR SIZE (Radius)\n                // GAUSSIAN BLUR SETTINGS }}}\n            \n                vec2 Radius = Size/vec2(1920.,1920.);\n                \n                \n                // Pixel colour\n                vec4 Color = texture(tx, uv);\n                \n                // Blur calculations\n                for( float d=0.0; d<Pi; d+=Pi/Directions)\n                {\n                    for(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n                    {\n                        Color += texture( tx, uv+vec2(cos(d),sin(d))*Radius*i);\t\t\n                    }\n                }\n                \n                // Output to screen\n                Color /= Quality * Directions - 15.0;\n                return Color.r;\n            }\n            void main() {\n                vec2 uv = vUv;\n                vec2 uv2 = vUv2;\n                vec3 nDetail = texture2D(nTexture,uv).rgb;\n                vec3 nDetail2 = texture2D(nTexture,uv2).rgb;\n                vec3 n = normalize(v_normal+nDetail-nDetail2);\n                vec3 nv_color = n*0.5  + 0.5;\n                vec4 final2 = vec4(nv_color,1.);\n                gNormal = final2;\n\n                // vec3 shadowCoord = (v_posFromLight.xyz/v_posFromLight.w)/2.0 + 0.5;\n                // float depth = texture2D(depthTextureFromLightCamera, shadowCoord.xy).r; //blur\n                // float visibility = (shadowCoord.z > depth) ? 1. : .0; // 判断片元是否在阴影中\n\n                \n                vec4 finalColor = vec4(0.05,0.05,0.08,1.);\n                // finalColor.rgb -= (nDetail.r+nDetail.g+nDetail.b)/3.;\n                \n                // vec2 texSize  = u_resolution;\n                // vec2 screen = gl_FragCoord.xy / texSize;\n                // finalColor.rgb-= (screen.y)*0.2;\n                vec4 sd;\n                // if(visibility==1.){\n                //     sd = vec4(1.,1.,1.,1.);\n                // }else{\n                //     sd = vec4(0.,0.,0.,0.);\n                // }\n                gColor  = finalColor;\n                // onlyShadow = sd;\n            }"});return this.material=n,n}},{key:"resize",value:function(e,n){this.targetN.setSize(e,n),this.target.setSize(e,n),this.targetLightCamera.setSize(e,n)}},{key:"loop",value:function(e){this.composer.renderer.setRenderTarget(this.target),this.composer.renderer.render(this.scene,this.camera),this.shaderPass.uniforms.tDepth.value=this.target.depthTexture,this.composer.renderer.setRenderTarget(this.targetLightCamera),this.composer.renderer.render(this.scene,this.lightCamera),this.material&&(this.material.uniforms["depthTextureFromLightCamera"].value=this.targetLightCamera.depthTexture),this.material.uniforms["time"].value=e,this.composer.renderer.setRenderTarget(this.targetN),this.composer.renderer.render(this.scene2,this.camera),this.shaderPass.uniforms.tNormal.value=this.targetN.texture[1],this.shaderPass.uniforms.groundTexture.value=this.targetN.texture[0],this.shaderPass.uniforms.groundDepth.value=this.targetN.depthTexture,this.shaderPass.uniforms.projectionMatrixInverse.value=this.camera.projectionMatrixInverse,this.shaderPass.uniforms.cameraProjectionMatrix.value=this.camera.projectionMatrix,this.shaderPass.uniforms.cameraViewMatrix.value=this.camera.matrixWorldInverse,this.shaderPass.uniforms.u_worldMatrix.value=this.camera.matrixWorld,this.composer.renderer.setRenderTarget(null)}}]),e}(),te=t("34ad"),re=(t("4ec9"),t("d3b7"),t("3ca3"),t("ddb0"),function(){function e(n){Object(X["a"])(this,e),this.mytexture,this.pjCamera=new J["ab"](30,2,.01,1e3),this.pjCamera.rotation.x=Math.PI-.022*Math.PI,this.pjCamera.position.y=70,this.pjCamera.position.z=0,this.camera=n.camera,this.comp=n.comp,n.scene.add(this.pjCamera),this.target=n.target,this.targetLight=this.setupRenderTargetLight(),this.scene=n.scene,this.txList=new Map;var t=this,r=(new J["vb"]).load(window.baseUrl+"/show/热力图.jpg",(function(e){t.txList.set("heat",r)})),i=(new J["vb"]).load(window.baseUrl+"/show/视频融合.jpg",(function(e){t.txList.set("vid",i)})),a=(new J["vb"]).load(window.baseUrl+"/show/视域.jpg",(function(e){t.txList.set("viewShed",a)})),o=(new J["vb"]).load(window.baseUrl+"/show/水淹.jpg",(function(e){t.txList.set("water",o)})),s=(new J["vb"]).load(window.baseUrl+"/show/水晶.png",(function(e){t.txList.set("CO2",s)})),l=(new J["vb"]).load(window.baseUrl+"/show/cloth.jpg",(function(e){t.txList.set("phy",l)}));this.shaderPass=new ee["a"]({glslVersion:J["v"],uniforms:{tDiffuse:{value:null},tDepth:{value:null},tDepthLight:{value:null},cameraNear:{value:n.camera.near},cameraFar:{value:n.camera.far},cameraProjectionMatrixInverse_lightCamera:{value:this.pjCamera.projectionMatrixInverse},cameraProjectionMatrix_lightCamera:{value:this.pjCamera.projectionMatrix},projectionMatrixInverse:{value:n.camera.projectionMatrixInverse},matrixWorldMain:{value:n.camera.matrixWorld},matrixWorldInverse_lightCamera:{value:this.pjCamera.matrixWorldInverse},myTexture:{value:this.mytexture}},vertexShader:"\n            varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                vec3 p = position;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( p, 1.0 );\n            }\n            ",fragmentShader:"\n            #include <packing>\n            uniform sampler2D tDiffuse;\n            uniform sampler2D tDepth;\n            varying vec2 vUv;\n            uniform sampler2D tDepthLight;\n            uniform float cameraNear;\n            uniform float cameraFar;\n            uniform mat4 projectionMatrixInverse;//*\n            uniform mat4 matrixWorldMain;//*\n            uniform mat4 cameraProjectionMatrixInverse_lightCamera;//*\n            uniform mat4 matrixWorldInverse_lightCamera;//*\n            uniform mat4 cameraProjectionMatrix_lightCamera;//*\n            uniform sampler2D myTexture;\n            vec4 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n                vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n                clipPosition *= clipW; //clip\n                return ( projectionMatrixInverse * clipPosition );//view\n            }\n                \n            void main() {\n                vec4 final = texture2D(tDiffuse,vUv);\n                float d = texture2D( tDepth, vUv).r; \n                vec4 ndc = vec4(\n                (vUv.x - 0.5) * 2.0,\n                (vUv.y - 0.5) * 2.0,\n                (d - 0.5) * 2.0,\n                1.0);\n                vec4 clip = projectionMatrixInverse * ndc;\n                vec4 wd = matrixWorldMain* (clip / clip.w);\n                //将世界坐标转为光相机视角的坐标，对比viewZ\n                vec4 eyePosInLightCamera = matrixWorldInverse_lightCamera*wd;\n                float zMainToLight = eyePosInLightCamera.z;//用于对比的Z\n                vec2 shadowUV;\n                vec4 clip2 = cameraProjectionMatrix_lightCamera*eyePosInLightCamera;\n                clip2.xyz/=clip2.w;\n                shadowUV = clip2.xy*0.5+0.5;\n            \n                float dLightCamera = texture2D( tDepthLight, shadowUV).r; \n                //求光相机的视图空间Z轴\n                vec4 ndcLightCamera = vec4(\n                (shadowUV.x - 0.5) * 2.0,\n                (shadowUV.y - 0.5) * 2.0,\n                (dLightCamera - 0.5) * 2.0,\n                1.0);\n                vec4 clipLightCamera = cameraProjectionMatrixInverse_lightCamera*ndcLightCamera;\n                vec4 eyePosLightCamera = clipLightCamera/clipLightCamera.w;\n                float zShadow = eyePosLightCamera.z; //用于对比的Z\n                float bias = 1.; //偏移值，越大越不容易出现条状阴影，但精准度会变差\n                if(shadowUV.x>0. && shadowUV.x<1. && shadowUV.y>0. && shadowUV.y<1.){\n                    if(zShadow>zMainToLight+bias || zMainToLight>0.){\n                        // final = vec4(1.,0.,0.,1.);\n                    }else{\n                        shadowUV.y = 1.-shadowUV.y;\n                        shadowUV.x = 1.-shadowUV.x;\n                        vec4 proj = texture2D(myTexture,shadowUV.xy);\n                        proj.rgb*=0.7;\n                        final.rgb = mix(final.rgb,proj.rgb,0.8);\n                    }\n                }\n                gl_FragColor = final;\n\n            }\n            "})}return Object(H["a"])(e,[{key:"loop",value:function(e){this.shaderPass.uniforms.tDepth.value=this.target.depthTexture,this.shaderPass.uniforms.matrixWorldMain.value=this.camera.matrixWorld,this.shaderPass.uniforms.projectionMatrixInverse.value=this.camera.projectionMatrixInverse,this.shaderPass.uniforms.matrixWorldInverse_lightCamera.value=this.pjCamera.matrixWorldInverse,this.shaderPass.uniforms.cameraProjectionMatrixInverse_lightCamera.value=this.pjCamera.projectionMatrixInverse,this.shaderPass.uniforms.cameraProjectionMatrix_lightCamera.value=this.pjCamera.projectionMatrix,this.comp.renderer.setRenderTarget(this.targetLight),this.comp.renderer.render(this.scene,this.pjCamera),this.shaderPass.uniforms.tDepthLight.value=this.targetLight.depthTexture,this.comp.renderer.setRenderTarget(null)}},{key:"setupRenderTargetLight",value:function(){var e=new J["Db"](2*window.width,2*window.height);return e.texture.minFilter=J["U"],e.texture.magFilter=J["U"],e.stencilBuffer=J["m"]===J["n"],e.depthTexture=new J["o"],e.depthTexture.format=J["m"],e.depthTexture.type=J["t"],e.setSize(window.width,window.height),e}},{key:"loadMyTexture",value:function(e){var n=this,t=this.txList.get(e);n.shaderPass.uniforms.myTexture.value=t}}]),e}()),ie=t("ade3"),ae=t("4a8d"),oe=t("22b5");function se(e){for(var n=[],t=0;t<5e3;t++){var r=J["N"].randFloatSpread(2e3),i=J["N"].randFloatSpread(2e3),a=J["N"].randFloatSpread(2e3);n.push(r,i,a)}Q=new J["h"],Q.setAttribute("position",new J["s"](n,3));var o=new J["eb"]({color:8947848}),s=new J["db"](Q,o);e.add(s)}function le(){oe.update()}function ce(e,n){if(!window.loader){window.loader=new ae["a"];var t=window.baseUrl+"/fonts/dzkl_Regular.json";loader.load(t,(function(t){if(window.fontUtil=t,window.fontUtil&&e){var r=window.fontUtil.generateShapes(e,50),i=new J["mb"](r);n(i.attributes.position),i=void 0}}))}if(window.fontUtil&&e){var r=window.fontUtil.generateShapes(e,50),i=new J["mb"](r);n(i.attributes.position),i=void 0}}function ue(e,n){if(!Q)return!1;for(var t=Q.getAttribute("position"),r=0;r<t.count;r++){var i,a=new oe.Tween(t.array),o=r%e.count;a.to((i={},Object(ie["a"])(i,3*r,-e.array[3*o]-n.x),Object(ie["a"])(i,3*r+1,e.array[3*o+1]-n.y),Object(ie["a"])(i,3*r+2,e.array[3*o+2]-n.z),i),3e3*Math.random()),a.easing(oe.Easing.Exponential.In),a.delay(0),a.onUpdate((function(){t.needsUpdate=!0})),a.start()}}var ve,me,he=t("22b5");function de(e,n,t){ve=t;var r={x:e.x,y:e.y,z:e.z},i=new he.Tween(r);i.to({x:n.x,y:n.y,z:n.z},3e3),i.easing(he.Easing.Quadratic.Out).onUpdate((function(){window.camera.position.set(r.x,r.y,r.z)})),i.start()}function pe(){ve&&window.camera.lookAt(ve.x,ve.y,ve.z),he.update()}var fe={mounted:function(){var e,n,t,r,i,a,o=document.getElementsByClassName("mbBody")[0];window.height=o.clientHeight,window.width=o.clientWidth,window.baseUrl="https://shaopinglin.github.io/webgl";var s=new J["kb"];s.background=new J["k"](5601194),window.camera=new J["ab"](90,window.width/window.height,.01,15e4),s.add(camera);var l=new J["cb"](16777215,.5,500);l.position.set(0,30,100),s.add(l);var c=new J["f"](15,15,15),u=new J["Q"]({color:65280}),v=new J["P"](c,u);v.position.z=100,v.position.y=50,s.add(v),window.lightCamera=new J["ab"](10,1,.1,1e4),lightCamera.position.x=0,lightCamera.position.y=4e3,lightCamera.position.z=5e3,lightCamera.lookAt(0,0,0),lightCamera.updateMatrixWorld(),s.add(lightCamera);var m=new J["rb"](300,32,16),h=new J["Q"]({color:new J["k"](1,1,1)}),d=new J["P"](m,h);d.position.y=lightCamera.position.y,d.position.z=lightCamera.position.z,d.position.x=lightCamera.position.x,s.add(d);var p=new J["rb"](2e4,64,64),f=new J["lb"]({side:J["c"],uniforms:{moonPos:{value:d.position}},glslVersion:J["v"],vertexShader:"\n            uniform vec3 moonPos;\n            varying float moonLightPow;\n            varying vec2 uv_;\n            void main(){\n                uv_ = uv;\n                vec4 wPos = modelMatrix * vec4( position, 1.0 );\n                float n = distance(moonPos,wPos.xyz);\n                moonLightPow = 1.-n/17000.;\n                gl_Position = projectionMatrix * viewMatrix * wPos;\n            }\n        ",fragmentShader:"\n            #include <packing>\n            layout(location = 0) out vec4 gColor;\n            varying float moonLightPow;\n            varying vec2 uv_;\n            float random(vec2 fv, float d1, float d2, float r) {\n                return fract(sin(dot(fv, vec2(d1, d2))) * r);\n            }\n            void main(){\n                vec4 baseColor = vec4(.05,.05,.08,1.);\n                baseColor.rgb+=moonLightPow;\n\n                //star\n                vec2 sv = uv_ +  .0005;\n                sv*=10.;\n                \n                vec2 iv = floor(sv * 500.0);\n                vec2 iv2 = floor(sv * 300.0);\n                vec2 iv3 = floor(sv * 400.0);\n                \n                vec3 cell_noise1 = vec3(random(iv, 12.0, 80.0, 4000.0));\n                vec3 cell_noise2 = vec3(random(iv2, 12.333, 13.0, 5000.0));\n                vec3 cell_noise3 = vec3(random(iv3, 90.4325, 12.0, 2000.0));\n                vec3 cell_noise = ((cell_noise1 + cell_noise2 + cell_noise3) * .3333 - .9) * 10.0;\n                \n                vec2 fv_s = uv_ * 20.0;\n                vec2 fv = fract(vec2(fv_s.x + sin( .005) * 10.0, fv_s.y + cos( .005) * 10.0) * .5);\n                vec3 circle = vec3(1.0 - smoothstep(length(fv - .25), .0, (sin(uv_.x * 40.0) * cos(uv_.y * 50.0)) * .015));\n                vec3 star = circle + clamp(cell_noise, .0, 1.0);\n                \n                baseColor.rgb+=star;\n                gColor = baseColor; //v_wPos,\n            }\n        "}),g=new J["P"](p,f);s.add(g);var w=new J["p"](16777215,1);w.position.x=0,w.position.y=4e3,w.position.z=5e3,w.lookAt(0,0,0),se(s);var x=new J["Eb"]({antialias:!0});function y(){camera.aspect=window.width/window.height,camera.updateProjectionMatrix(),lightCamera.aspect=window.width/window.height,lightCamera.updateProjectionMatrix(),e.renderer.setSize(window.width,window.height),e.setSize(window.width,window.height),i.resize(window.width,window.height),r&&r.resize(),a&&a.setSize(window.width,window.height)}x.setSize(window.width,window.height),x.setAnimationLoop(D),t=new K["a"](s,camera),e=new q["a"](x),e.addPass(t),camera.position.set(123.68603126398743,50.0352703064332,-139.56146400555667),camera.lookAt(0,65,150),o.appendChild(x.domElement),window.onresize=y,a=P();var b=(new J["vb"]).load(window.baseUrl+"/noise/perlin.png",(function(n){b.wrapS=J["jb"],b.wrapT=J["jb"],b.repeat.set(10,10);var t=new J["kb"];r=new Y({camera:camera,lightCamera:lightCamera,noiseTexture:b,composer:e,scene3:t,target:a});var i=r.createCloud();s.add(i)})),j=(new J["vb"]).load(window.baseUrl+"/textures/waterN8.jpg",(function(t){(new te["a"]).setPath(window.baseUrl+"/bigScreen/").load("scene.glb",(function(e){var n=e.scene;n.position.y=0,n.position.z=200,n.rotation.y=Math.PI,n.scale.x=15,n.scale.y=15,n.scale.z=15,n.traverse((function(e){e.isMesh&&(e.material.transparent=!0)})),s.add(n)})),j.wrapS=J["jb"],j.wrapT=J["jb"],j.repeat.set(2,2);var r=new J["kb"];me=new re({comp:e,scene:s,target:a,camera:camera}),e.addPass(me.shaderPass),i=new ne({lightCamera:lightCamera,camera:camera,scene:s,scene2:r,target:a,composer:e}),n=i.shaderPass,e.addPass(n);var o={exposure:.2,bloomStrength:.5,bloomThreshold:0,bloomRadius:.5},l=new $["a"](new J["zb"](window.width,window.height),1.5,.4,.85);l.threshold=o.bloomThreshold,l.strength=o.bloomStrength,l.radius=o.bloomRadius,e.addPass(l);var c=new J["bb"](3e3,3e3,500,500),u=j,v=i.getShadowMaterial(u),m=new J["P"](c,v);m.rotation.x=-Math.PI/2,m.position.y=0,m.scale.x=4,m.scale.y=4,m.scale.z=2,r.add(m),M(e)}));function P(){var e=new J["Db"](window.width,window.height);return e.texture.minFilter=J["U"],e.texture.magFilter=J["U"],e.stencilBuffer=J["m"]===J["n"],e.depthTexture=new J["o"],e.depthTexture.format=J["m"],e.depthTexture.type=J["t"],e}var C=0;function D(n){le(),C+=1,C%2!=1&&(C>59&&(C=0),camera.position.y>400&&(camera.position.y=400),camera.position.y<10&&(camera.position.y=10),r&&r.loop(n),me&&me.loop(n),i&&i.loop(n),e&&e.render(),camera.matrixWorldNeedsUpdate=!0,g.rotation.y+=1e-4,g.rotation.x+=1e-4,v.position.y=50+20*Math.sin(.001*n),v.position.x=20*Math.cos(.001*n),pe())}function M(){var n=new ee["a"]({glslVersion:J["v"],uniforms:{tDiffuse:{value:null},tDepth:{value:null}},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            vec3 p = position;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( p, 1.0 );\n        }\n        ",fragmentShader:"\n        #include <packing>\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDepth;\n        varying vec2 vUv;\n        const int samples = 35,\n        LOD = 2,         // gaussian done on MIPmap at scale LOD\n        sLOD = 1 << LOD; // tile size = 2^LOD\n        const float sigma = float(samples) * .25;\n\n        float gaussian(vec2 i) {\n            return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n        }\n\n        vec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n            vec4 O = vec4(0);  \n            int s = samples/sLOD;\n            \n            for ( int i = 0; i < s*s; i++ ) {\n                vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n                O += gaussian(d) * textureLod( sp, U + scale * d , float(LOD) );\n            }\n            \n            return O / O.a;\n        }\n        void main() {\n            vec4 final = texture2D(tDiffuse,vUv);\n            float dist = distance(vUv,vec2(0.5))*0.5;\n            \n            gl_FragColor = final;//blur( tDiffuse, vUv, dist/vec2(1440.,900.) );\n\n        }\n        "});e.addPass(n)}},data:function(){return{curPg:0,showMenu:!1,contentText:"\n      欢迎访问我的个人主页！！我是一名WebGL开发者。欢迎同志共同交流技术。",text:["\n      欢迎访问我的个人主页。我是一名WebGL开发者。欢迎同志共同交流技术。","\n        Three.js和Cesium是我最主要使用的图形库，着色器语言在WebGL中统一使用glsl。\n        前端框架方面，Vue、Webpack是我较为常用的技术。\n        第三方库常用的如Echarts、ElementUI、TweenJS等。\n        浏览器提供的API如webWorker、 IndexedDB等常用来作为优化程序性能和数据存储。\n        项目经验：\n        1、响水县公安系统：该项目我个人负责“Gis工具包”的开发，基于Cesium进行如测绘工具、倾斜摄影模型加载(非3Dtile)、手工模型加载、视域分析、视频融合和热力图等一系列功能的开发。\n        2、厦门中医专病平台：毕业时通过校园招聘应聘的Java实习，北京的某外包国企公司，甲方是厦门市卫委，我主要负责Java后端开发和前端图表的制作。经历了工作后发现Java并不是我热衷的技术方向，这也是导致我转型做WebGL的一个契机。\n        3、在线3D试衣平台：该项目前端和后端皆由我独立完成，后端是使用SpringBoot+MySql数据库+Shiro权限认证构成，并部署在Docker环境。前端部分的3D渲染使用Three.js，服装物理布料模拟使用了Ammo.js物理引擎，页面部分则是使用原生JS+HTML，该项目是本人毕业设计作品。\n        ","","\n        邮箱：524942251@qq.com\n        "]}},methods:{changeWoker:function(e){me.loadMyTexture(e)},openMenu:function(){this.showMenu=!this.showMenu},jump:function(e,n){var t;switch(this.showMenu=!1,this.curPg=e,e){case 0:this.contentText=this.text[e],t={x:-0,y:-120,z:-50},de({x:window.camera.position.x,y:window.camera.position.y,z:window.camera.position.z},{x:123.68603126398743,y:50.0352703064332,z:-139.56146400555667},{x:0,y:65,z:150});break;case 1:this.contentText=this.text[e],t={x:-200,y:-150,z:-150},de({x:window.camera.position.x,y:window.camera.position.y,z:window.camera.position.z},{x:123.68603126398743,y:50.0352703064332,z:-139.56146400555667},{x:0,y:65,z:150});break;case 2:this.contentText="\n                ",de({x:window.camera.position.x,y:window.camera.position.y,z:window.camera.position.z},{x:0,y:65,z:50},{x:0,y:65,z:150}),t={x:-150,y:-120,z:-50};break;case 3:this.contentText=this.text[e],t={x:-100,y:-365,z:-250},de({x:window.camera.position.x,y:window.camera.position.y,z:window.camera.position.z},{x:0,y:365,z:110},{x:0,y:365,z:150});break}ce(n,(function(e){ue(e,t)}))}}};t("61d6");const ge=o()(fe,[["render",Z],["__scopeId","data-v-020dc968"]]);var we=ge,xe=[{path:"/",name:"Home",component:p},{path:"/mobia",name:"Mobia",component:we}],ye=Object(u["a"])({history:Object(u["b"])(),routes:xe}),be=function(){var e=navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);return e};setTimeout((function(){var e=be();e?ye.push({path:"/mobia"}):ye.push({path:"/"})}),10);var je=ye;Object(r["b"])(c).use(je).mount("#app")},"61d6":function(e,n,t){"use strict";t("7ab3")},"7ab3":function(e,n,t){},f941:function(e,n,t){}});